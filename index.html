<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>Azbry Tap Runner</title>
<style>
  :root{--bg:#0b0d10;--panel:#111418;--muted:#9aa3b2;--text:#e7eaee;--accent:#b8ff9a;--accent2:#8ee887}
  html,body{margin:0;height:100%;background:#0b0d10;color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  #wrap{max-width:700px;margin:0 auto;padding:10px 12px}
  h1{margin:6px 0 8px;font-size:18px;font-weight:800;letter-spacing:.3px}
  .card{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:10px 12px}
  canvas{display:block;width:100%;height:auto;border-radius:12px;background:#0b0d10;box-shadow:0 8px 30px rgba(0,0,0,.35)}
  .hint{margin-top:8px;color:var(--muted);font-size:12px}
</style>
</head>
<body>
  <div id="wrap">
    <div class="card">
      <h1>Azbry Tap Runner</h1>
      <canvas id="game" width="720" height="420"></canvas>
      <div class="hint">Tap layar / klik / tekan spasi untuk lompat. Capai skor 100!</div>
    </div>
  </div>

<script>
(() => {
  // ==== Assets
  const BIRD_SRC = "https://files.catbox.moe/9whqg7.jpg";
  const BG_SRC   = "https://files.catbox.moe/0ub3wk.jpg";

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Responsif (rasio 720x420)
  function fit() {
    const w = canvas.parentElement.clientWidth;
    const scale = Math.min(1, w/720);
    canvas.style.width = (720*scale)+'px';
    canvas.style.height = (420*scale)+'px';
  }
  addEventListener('resize', fit); fit();

  // ==== Game state
  let assetsReady = 0;  // jalanin loop setelah 2 gambar loaded
  let running = false, gameOver = false, score = 0, best = 0;
  const G = 0.65, JUMP = -10.2, FLOOR_H = 56, SPEED = 4;
  let t = 0;

  // player
  const player = { x: 90, y: 0, w: 44, h: 44, vy: 0, sprite: new Image() };
  player.sprite.crossOrigin = "anonymous";
  player.sprite.onload = onAssetReady;
  player.sprite.src = BIRD_SRC;

  // background
  const bg = new Image();
  bg.crossOrigin = "anonymous";
  bg.onload = onAssetReady;
  bg.src = BG_SRC;
  let bgX = 0, bgScale = 1;

  function onAssetReady(){
    assetsReady++;
    if (assetsReady === 2) startGame();
  }

  function startGame(){
    reset();
    running = true;
    requestAnimationFrame(loop);
  }

  const obstacles = [];
  const SPAWN_EVERY = 90;
  const OB_W = 44, OB_H_MIN = 26, OB_H_MAX = 66;

  const rnd = (a,b)=>Math.floor(a+Math.random()*(b-a+1));
  function reset() {
    obstacles.length = 0; score = 0; t = 0; bgX = 0;
    player.y = canvas.height - FLOOR_H - player.h;
    player.vy = 0;
    running = true; gameOver = false;
  }

  // input
  function jump() {
    if (!running) { reset(); return; }
    if (gameOver)  { reset(); return; }
    const groundY = canvas.height - FLOOR_H - player.h;
    if (player.y >= groundY - 2) player.vy = JUMP;
  }
  addEventListener('keydown', e => { if(e.code==='Space'){ e.preventDefault(); jump(); }});
  canvas.addEventListener('pointerdown', jump);
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); jump(); }, {passive:false});

  // lantai
  function drawFloor() {
    const y = canvas.height - FLOOR_H;
    const grad = ctx.createLinearGradient(0,y,0,canvas.height);
    grad.addColorStop(0,'#0d1116'); grad.addColorStop(1,'#0a0d10');
    ctx.fillStyle = grad; ctx.fillRect(0, y, canvas.width, FLOOR_H);
    ctx.strokeStyle = 'rgba(184,255,154,.28)'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, y + .5); ctx.lineTo(canvas.width, y + .5); ctx.stroke();
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.max(0, Math.min(r, Math.min(w,h)/2));
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawObstacle(o) {
    const r = 8;
    ctx.fillStyle = '#14181d';
    roundRect(ctx, o.x, o.y, o.w, o.h, r); ctx.fill();
    ctx.save();
    ctx.shadowColor = '#b8ff9a'; ctx.shadowBlur = 16;
    ctx.strokeStyle = '#b8ff9a'; ctx.lineWidth = 2;
    roundRect(ctx, o.x, o.y, o.w, o.h, r); ctx.stroke();
    ctx.restore();
    ctx.strokeStyle = 'rgba(184,255,154,.25)'; ctx.lineWidth = 1;
    roundRect(ctx, o.x+4, o.y+4, o.w-8, o.h-8, r-4); ctx.stroke();
  }

  // spawn dari bawah (ground) atau dari atas (hanging)
  function spawnObstacle() {
    const fromTop = Math.random() < 0.4; // 40% atas, 60% bawah
    const h = rnd(OB_H_MIN, OB_H_MAX);

    if (fromTop) {
      const topMargin = 36;                 // jarak aman dari tepi
      const maxH = Math.min(h, canvas.height - FLOOR_H - 110); // jangan tutup jalan
      obstacles.push({ x: canvas.width + 10, y: topMargin, w: OB_W, h: Math.max(24, maxH), top: true });
    } else {
      const y = canvas.height - FLOOR_H - h;
      obstacles.push({ x: canvas.width + 10, y, w: OB_W, h, top: false });
    }
  }

  function hit(a,b){ return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h); }

  function loop() {
    if (running) requestAnimationFrame(loop);
    if (!assetsReady) return;

    t++;
    // update fisika
    player.vy += G; player.y += player.vy;
    const groundY = canvas.height - FLOOR_H - player.h;
    if (player.y > groundY) { player.y = groundY; player.vy = 0; }

    // bg scroll
    bgScale = canvas.height / bg.height;
    const bgW = bg.width * bgScale;
    bgX -= SPEED * 0.5; if (bgX <= -bgW) bgX += bgW;

    // spawn
    if (t % SPAWN_EVERY === 0) spawnObstacle();

    // move obs
    for (let i=obstacles.length-1; i>=0; i--) {
      const o = obstacles[i]; o.x -= SPEED;
      if (o.x + o.w < 0) obstacles.splice(i,1);
      if (!o.passed && o.x + o.w < player.x) { o.passed = true; score++; }
    }

    // collision
    for (const o of obstacles) if (hit(player,o)) { endGame(); break; }

    // DRAW
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // bg repeat
    ctx.drawImage(bg, bgX, 0, bgW, canvas.height);
    ctx.drawImage(bg, bgX + bgW, 0, bgW, canvas.height);

    drawFloor();
    obstacles.forEach(drawObstacle);

    // player (shadow kecil)
    ctx.save(); ctx.shadowColor = 'rgba(0,0,0,.6)'; ctx.shadowBlur = 10;
    ctx.drawImage(player.sprite, player.x, Math.round(player.y), player.w, player.h);
    ctx.restore();

    // HUD
    ctx.fillStyle = '#e7eaee'; ctx.font = '700 20px Inter,system-ui,sans-serif';
    ctx.fillText(`Score: ${score}`, 16, 30);
    ctx.fillStyle = '#9aa3b2'; ctx.font = '600 12px Inter,system-ui,sans-serif';
    ctx.fillText(`Best: ${best}`, 16, 48);

    if (gameOver) drawGameOver();
  }

  function endGame(){ gameOver = true; best = Math.max(best, score); }

  function drawGameOver(){
    ctx.fillStyle = 'rgba(0,0,0,.55)'; ctx.fillRect(0,0,canvas.width,canvas.height);
    const cx = canvas.width/2, W=Math.min(520,canvas.width-60), H=170, X=cx-W/2, Y=canvas.height/2-H/2;
    ctx.fillStyle = '#111418'; ctx.strokeStyle='rgba(255,255,255,.09)'; ctx.lineWidth=1.5;
    roundRect(ctx,X,Y,W,H,14); ctx.fill(); ctx.stroke();

    ctx.fillStyle='#e7eaee'; ctx.font='800 22px Inter,system-ui,sans-serif'; ctx.textAlign='center';
    ctx.fillText('Game Over', cx, Y+38);

    ctx.fillStyle='#9aa3b2'; ctx.font='600 14px Inter,system-ui,sans-serif';
    wrapText('Ayo coba lagi! Dapatkan 100 score dan kamu boleh mengambil hadiah dari Febry.',
             cx, Y+68, W-40, 18);

    const btnW=160, btnH=40, btnX=cx-btnW/2, btnY=Y+H-52;
    ctx.save(); ctx.shadowColor='#b8ff9a'; ctx.shadowBlur=16;
    let g = ctx.createLinearGradient(btnX,0,btnX+btnW,0);
    g.addColorStop(0,'#b8ff9a'); g.addColorStop(1,'#8ee887'); ctx.fillStyle=g;
    roundRect(ctx,btnX,btnY,btnW,btnH,10); ctx.fill(); ctx.restore();
    ctx.fillStyle='#0b0d10'; ctx.font='800 14px Inter,system-ui,sans-serif'; ctx.fillText('Main Lagi', cx, btnY+26);

    canvas.onclick = (e)=>{
      if (!gameOver) return;
      const rect = canvas.getBoundingClientRect();
      const sx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const sy = (e.clientY - rect.top)  * (canvas.height / rect.height);
      if (sx>=btnX && sx<=btnX+btnW && sy>=btnY && sy<=btnY+btnH) { reset(); }
    };
  }

  function wrapText(text, x, y, maxW, lh){
    const words=text.split(' '); let line='', yy=y; ctx.textAlign='center';
    for(let n=0;n<words.length;n++){
      const test=line+words[n]+' '; const w=ctx.measureText(test).width;
      if (w>maxW && n>0){ ctx.fillText(line.trim(), x, yy); line=words[n]+' '; yy+=lh; }
      else line=test;
    }
    ctx.fillText(line.trim(), x, yy);
  }
})();
</script>
</body>
</html>
